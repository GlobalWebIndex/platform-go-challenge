package gwi

import (
	"bytes"
	"encoding/json"
	"errors"
	"log"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/google/uuid"
	"github.com/gorilla/mux"
	"github.com/stretchr/testify/assert"
)

func TestValidateUuid(t *testing.T) {
	assert := assert.New(t)

	tests := []struct {
		Description    string
		Input          string
		ExpectedResult bool
	}{
		{
			Description:    "when the input is not a valid uuid",
			Input:          "foo",
			ExpectedResult: false,
		},
		{
			Description:    "when the input is a valid uuid",
			Input:          "d2a7924e-765f-4949-bc4c-219c956d0f8b",
			ExpectedResult: true,
		},
		{
			Description:    "when the input is an uuid without -",
			Input:          "d2a7924e765f4949bc4c-219c956d0f8b",
			ExpectedResult: false,
		},
		{
			Description:    "when the input is a valid uuid generated by uuid package",
			Input:          uuid.New().String(),
			ExpectedResult: true,
		},
	}

	for _, test := range tests {
		t.Run(test.Description, func(t *testing.T) {
			output := ValidateUuid(test.Input)
			assert.Equal(test.ExpectedResult, output)
		})
	}
}

func TestGetUuid(t *testing.T) {
	assert := assert.New(t)

	testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
	}))
	defer func() { testServer.Close() }()

	empty := ""
	uuid := uuid.New().String()

	tests := []struct {
		Description    string
		Input          map[string]string
		ExpectedResult string
	}{
		{
			Description:    "when the input does not have userid path element",
			Input:          map[string]string{},
			ExpectedResult: empty,
		},
		{
			Description: "when the input is a valid uuid value",
			Input: map[string]string{
				"userid": uuid,
			},
			ExpectedResult: uuid,
		},
	}

	for _, test := range tests {
		t.Run(test.Description, func(t *testing.T) {
			log.Println(test.Input)
			req := httptest.NewRequest(http.MethodGet, testServer.URL, nil)
			req = mux.SetURLVars(req, test.Input)
			output := GetUuid(req)
			assert.Equal(test.ExpectedResult, output)
		})
	}
}

func TestDecode(t *testing.T) {
	assert := assert.New(t)

	type input struct {
		req  *http.Request
		tipe interface{}
	}

	type dummy struct{}

	type output struct {
		Element interface{}
		Error   error
	}

	testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
	}))
	defer func() { testServer.Close() }()

	marshaledBody, err := json.Marshal(Asset{})
	assert.Nil(err)

	tests := []struct {
		Description     string
		Input           input
		ExpectedOutput  output
		ExpectedSuccess bool
	}{
		{
			Description: "when the input type is not a expected entity, should return a nil element and no error",
			Input: input{
				req:  &http.Request{},
				tipe: dummy{},
			},
			ExpectedOutput: output{
				Element: nil,
				Error:   nil,
			},
			ExpectedSuccess: true,
		},
		{
			Description: "when the input type is an Asset entity, but the body does not represent an Asset payload, should return nil element and EOF error",
			Input: input{
				req:  httptest.NewRequest(http.MethodGet, testServer.URL, nil),
				tipe: Asset{},
			},
			ExpectedOutput: output{
				Element: nil,
				Error:   errors.New("EOF"),
			},
			ExpectedSuccess: false,
		},
		{
			Description: "when the input type is an Asset entity, and the body represents a valid Asset payload, should return an Asset entity and nil error",
			Input: input{
				req:  httptest.NewRequest(http.MethodPost, testServer.URL, bytes.NewBuffer(marshaledBody)),
				tipe: Asset{},
			},
			ExpectedOutput: output{
				Element: Asset{},
				Error:   nil,
			},
			ExpectedSuccess: true,
		},
	}

	for _, test := range tests {
		t.Run(test.Description, func(t *testing.T) {
			output, err := Decode(test.Input.req, test.Input.tipe)
			if test.ExpectedSuccess {
				assert.NoError(err)
			} else {
				assert.NotNil(err)
			}
			assert.Equal(test.ExpectedOutput.Element, output)
		})
	}
}
